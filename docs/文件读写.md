# 单次扫描 + 延迟决策文件读写架构

## 文档信息

| 项目 | 内容 |
|------|------|
| **架构版本** | 1.0.0 |
| **文档日期** | 2026-01-20 |
| **核心特性** | 零启动延迟、O(1) 内存、单次顺序扫描 |

---

## 1. 架构设计概述

### 1.1 传统方案的问题

**传统预扫描方案**：

```
┌─────────────────────────────────────────────────────────────┐
│                    传统预扫描方案                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: open()                                             │
│  ├── 预扫描整个文件 → 识别 Header/Footer                     │
│  ├── 记录 Header 信息                                        │
│  ├── 记录 Footer 位置                                        │
│  └── ❌ 启动延迟高（大文件需要数秒甚至数分钟）                │
│                                                             │
│  Step 2: read()                                             │
│  ├── 从 Header 后开始读取                                    │
│  ├── 处理数据行                                              │
│  ├── 在 Footer 位置停止                                      │
│  └── ❌ 内存占用大（缓存整个文件或大量行）                    │
│                                                             │
│  性能问题:                                                   │
│  ├── 启动延迟: O(n) - n 为文件行数                           │
│  ├── 内存占用: O(n) - 需要缓存或多次读取                      │
│  └── I/O 次数: 2次 - 预扫描 + 正式读取                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 单次扫描方案（HeaderFooterAwareReader）

**延迟决策方案**：

```
┌─────────────────────────────────────────────────────────────┐
│              单次扫描 + 延迟决策方案                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: open()                                             │
│  └── 仅初始化资源，不扫描任何内容                            │
│      ✅ 零启动延迟                                           │
│                                                             │
│  Step 2: read() - 单次顺序扫描                              │
│  ├── 读取第一行 → 延迟判断是否为 Header                      │
│  │   ├── 是 Header → 解析并校验，继续读取                    │
│  │   └── 不是 Header → 作为数据处理                          │
│  ├── 读取中间行 → 作为数据处理                                │
│  └── 读取最后一行 → 延迟判断是否为 Footer                     │
│      ├── 是 Footer → 解析并校验，返回 null                   │
│      └── 不是 Footer → 作为数据处理                          │
│                                                             │
│  性能优势:                                                   │
│  ├── 启动延迟: O(1) - 无需预扫描                             │
│  ├── 内存占用: O(1) - 只缓存 prevLine + currentLine          │
│  └── I/O 次数: 1次 - 单次顺序扫描                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 性能对比

| 指标 | 传统预扫描方案 | 单次扫描方案 | 提升 |
|------|---------------|-------------|------|
| **启动延迟** | O(n) - 数秒到数分钟 | O(1) - < 100ms | **100x+** |
| **内存占用** | O(n) - 与文件大小成正比 | O(1) - 恒定 | **n 倍** |
| **I/O 次数** | 2次（预扫描+读取） | 1次（单次扫描） | **2x** |
| **适用场景** | 小文件（< 100MB） | 任意大小（GB 级） | **无限制** |

---

## 2. HeaderFooterAwareReader 核心实现

### 2.1 状态机设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Reader 状态机                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────┐                                                            │
│  │  START   │  ← 初始状态                                               │
│  └────┬─────┘                                                            │
│       │ read()                                                           │
│       ▼                                                                  │
│  ┌──────────────┐                                                        │
│  │ FIRST_LINE   │  ← 第一行处理                                          │
│  │ (延迟判断)    │                                                        │
│  └──────┬───────┘                                                        │
│         │                                                                │
│         ├── [Header] → 解析Header → 校验 ───┐                            │
│         │                                  │                            │
│         ├── [数据行]  ──────────────────────┘                            │
│         │                                  │                            │
│         ▼                                  ▼                            │
│  ┌──────────────┐                  ┌──────────────┐                     │
│  │ DATA_STATE   │ ◄──────────────── │ DATA_STATE   │                     │
│  │ (正常处理)    │ ──read()────────── │ (继续处理)   │                     │
│  └──────┬───────┘                  └──────────────┘                     │
│         │                                                                │
│         │ read() 返回 null (EOF)                                         │
│         ▼                                                                  │
│  ┌──────────────┐                                                        │
│  │ FOOTER_CHECK │  ← 处理 prevLine（可能是最后一行）                     │
│  │ (延迟判断)    │                                                        │
│  └──────┬───────┘                                                        │
│         │                                                                │
│         ├── [Footer] → 解析Footer → 校验 → 返回 null                      │
│         │                                                                │
│         ├── [数据行]  → 处理 → actualRecordCount++ → 返回数据             │
│         │                                                                │
│         └── [空/null] → 返回 null                                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心代码

```java
public class HeaderFooterAwareReader<T> implements ItemReader<T> {

    // ===== 状态定义 =====
    private enum ReaderState {
        START,      // 初始状态
        DATA,       // 数据处理状态
        EOF         // 文件结束
    }

    // ===== 核心字段 =====
    private final Resource resource;
    private final LineTokenizer lineTokenizer;
    private final FieldSetMapper<T> fieldSetMapper;

    // Header/Footer 处理组件
    private final HeaderParser headerParser;
    private final HeaderValidator headerValidator;
    private final FooterParser footerParser;
    private final FooterValidator footerValidator;
    private final FooterLineDetector footerLineDetector;

    // ===== 状态字段 =====
    private BufferedReader reader;
    private ReaderState state = ReaderState.START;

    // 单次扫描核心：只缓存两行
    private String prevLine = null;      // 上一行（用于 EOF 时判断是否为 Footer）
    private String currentLine = null;   // 当前行

    // 统计信息
    private boolean firstLineRead = false;
    private long actualRecordCount = 0;

    private HeaderInfo headerInfo = HeaderInfo.empty();
    private FooterInfo footerInfo = FooterInfo.empty();

    // ===== 核心方法 =====
    @Override
    public void open(ExecutionContext executionContext) {
        reader = new BufferedReader(new InputStreamReader(resource.getInputStream()));
        resetState();  // 重置状态，支持重启
    }

    @Override
    public T read() throws Exception {
        // 确保有一行可用
        if (currentLine == null) {
            currentLine = reader.readLine();
            if (currentLine == null) {
                // EOF - 处理缓存的上一行
                return handleEndOfFile();
            }
        }

        // 状态机处理
        switch (state) {
            case START:
                return handleFirstLine();
            case DATA:
                return handleDataLine();
            case EOF:
                return null;
            default:
                throw new IllegalStateException("Unknown state: " + state);
        }
    }

    /**
     * 处理第一行 - 延迟判断是否为 Header
     */
    private T handleFirstLine() throws Exception {
        firstLineRead = true;

        if (isHeaderLine(currentLine)) {
            // 是 Header - 解析并校验
            headerInfo = headerParser.parse(currentLine);
            if (headerValidator != null) {
                headerValidator.validate(headerInfo);
            }
            advanceLine();
            // 递归调用，读取第一行数据
            return read();
        } else {
            // 不是 Header - 进入数据处理状态
            state = ReaderState.DATA;
            return handleDataLine();
        }
    }

    /**
     * 处理数据行 - 提前判断是否为 Footer
     */
    private T handleDataLine() throws Exception {
        // 提前判断当前行是否为 Footer
        if (footerParser != null && isFooterLine(currentLine)) {
            footerInfo = footerParser.parse(currentLine);
            if (footerValidator != null) {
                footerValidator.validate(footerInfo, actualRecordCount);
            }
            advanceLine();
            return null;
        }

        // 正常数据处理
        String lineToProcess = currentLine;
        advanceLine();
        actualRecordCount++;
        return processLine(lineToProcess);
    }

    /**
     * 处理文件结束 - 延迟判断最后一行是否为 Footer
     */
    private T handleEndOfFile() throws Exception {
        state = ReaderState.EOF;

        if (prevLine == null) {
            return null;  // 空文件
        }

        // 延迟判断：最后一行可能是 Footer
        if (footerParser != null && isFooterLine(prevLine)) {
            footerInfo = footerParser.parse(prevLine);
            if (footerValidator != null) {
                footerValidator.validate(footerInfo, actualRecordCount);
            }
            return null;
        }

        // 最后一行是数据行
        T result = processLine(prevLine);
        actualRecordCount++;
        prevLine = null;  // 防止无限循环
        return result;
    }

    /**
     * 推进行指针
     */
    private void advanceLine() {
        prevLine = currentLine;
        currentLine = reader.readLine();
    }

    /**
     * 判断是否为 Header 行
     */
    private boolean isHeaderLine(String line) {
        return line != null && !line.isBlank() && headerParser != null;
    }

    /**
     * 判断是否为 Footer 行
     */
    private boolean isFooterLine(String line) {
        if (line == null || line.isBlank()) return false;
        if (footerParser == null) return false;  // 未配置 Footer 解析器
        return footerLineDetector.isFooterLine(line);
    }

    /**
     * 处理单行数据
     */
    private T processLine(String line) throws Exception {
        FieldSet fieldSet = lineTokenizer.tokenize(line);
        return fieldSetMapper.mapFieldSet(fieldSet);
    }

    /**
     * 重置状态
     */
    private void resetState() {
        state = ReaderState.START;
        prevLine = null;
        currentLine = null;
        firstLineRead = false;
        actualRecordCount = 0;
        headerInfo = HeaderInfo.empty();
        footerInfo = FooterInfo.empty();
    }

    @Override
    public void close() {
        if (reader != null) {
            reader.close();
        }
    }
}
```

### 2.3 关键设计点

| 设计点 | 说明 | 代码位置 |
|--------|------|----------|
| **O(1) 缓存** | 只缓存 prevLine + currentLine | `prevLine`, `currentLine` |
| **延迟判断** | 第一行和最后一行延迟判断 | `handleFirstLine()`, `handleEndOfFile()` |
| **状态推进** | 处理后立即推进行指针 | `advanceLine()` |
| **防止循环** | handleEndOfFile 清空 prevLine | `prevLine = null` |
| **状态重置** | open() 时重置所有状态 | `resetState()` |

---

## 3. Footer 检测策略

### 3.1 FooterLineDetector 接口

```java
@FunctionalInterface
public interface FooterLineDetector {
    boolean isFooterLine(String line);

    static FooterLineDetector defaultDetector() {
        return new DefaultFooterLineDetector();
    }
}
```

### 3.2 默认检测规则

```java
public final class DefaultFooterLineDetector implements FooterLineDetector {

    // 规则1: 纯数字
    private static final Pattern PURE_NUMBER = Pattern.compile("^\\d+$");

    // 规则2: T| 前缀
    private static final Pattern T_PREFIX = Pattern.compile("^[Tt]\\|\\d+$");

    // 规则3: R 前缀（如 R00003）
    private static final Pattern R_PREFIX = Pattern.compile("^[Rr]\\d+$");

    @Override
    public boolean isFooterLine(String line) {
        if (line == null) return false;

        String trimmed = line.trim();

        return PURE_NUMBER.matcher(trimmed).matches()
            || T_PREFIX.matcher(trimmed).matches()
            || R_PREFIX.matcher(trimmed).matches();
    }
}
```

### 3.3 自定义检测规则

```java
// 场景1: T| 前缀
FooterLineDetector detector1 = line -> line.startsWith("T|");

// 场景2: COUNT: 前缀
FooterLineDetector detector2 = line -> line.startsWith("COUNT:");

// 场景3: 正则表达式
FooterLineDetector detector3 = line -> {
    Pattern pattern = Pattern.compile("^TOTAL:\\d+$");
    return pattern.matcher(line).matches();
};
```

---

## 4. 文件格式支持

### 4.1 格式1: yyyyMMdd + 纯数字 Footer

```
20260120
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
3
```

**配置**：

```java
HeaderParser headerParser = line -> {
    LocalDate date = LocalDate.parse(line, DateTimeFormatter.ofPattern("yyyyMMdd"));
    return new HeaderInfo(date);
};

HeaderValidator headerValidator = header -> {
    if (!header.getDate().equals(LocalDate.now())) {
        throw new IllegalStateException("Date mismatch");
    }
};

FooterParser footerParser = line -> {
    long count = Long.parseLong(line.trim());
    return new FooterInfo(count);
};

FooterValidator footerValidator = (footer, actual) -> {
    if (footer.getCount() != actual) {
        throw new IllegalStateException("Count mismatch");
    }
};
```

### 4.2 格式2: MMddyyyy + R 前缀 Footer

```
01202026
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
R00003
```

**配置**：

```java
HeaderParser headerParser = line ->
    new HeaderInfo(LocalDate.parse(line, DateTimeFormatter.ofPattern("MMddyyyy")));

FooterParser footerParser = line -> {
    String countStr = line.substring(1);  // 去掉 R
    long count = Long.parseLong(countStr);
    return new FooterInfo(count);
};
```

### 4.3 格式3: 无头尾

```
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
```

**配置**：

```java
// 不配置 HeaderParser 和 FooterParser
HeaderFooterAwareReader<DemoUser> reader = new HeaderFooterAwareReader<>(
    resource,
    null,   // headerParser
    null,   // headerValidator
    null,   // footerParser
    null,   // footerValidator
    lineTokenizer,
    fieldSetMapper
);
```

---

## 5. 文件导出架构

### 5.1 FlatFileItemWriter 扩展

**功能**：支持动态生成 Header 和 Footer

```java
public class HeaderFooterAwareItemWriter<T> extends FlatFileItemWriter<T> {

    private final HeaderGenerator headerGenerator;
    private final FooterGenerator footerGenerator;
    private final AtomicLong recordCount = new AtomicLong(0);

    @Override
    public void open(ExecutionContext executionContext) {
        super.open(executionContext);

        // 生成 Header
        if (headerGenerator != null) {
            String header = headerGenerator.generate(LocalDate.now());
            writeHeader(header);
        }
    }

    @Override
    public void write(List<? extends T> items) throws Exception {
        super.write(items);
        recordCount.addAndGet(items.size());
    }

    @Override
    public void close() {
        // 生成 Footer
        if (footerGenerator != null) {
            String footer = footerGenerator.generate(recordCount.get());
            writeFooter(footer);
        }
        super.close();
    }
}
```

### 5.2 Header/Footer 生成器

```java
// Header 生成器：yyyyMMdd
HeaderGenerator headerGenerator = date ->
    date.format(DateTimeFormatter.ofPattern("yyyyMMdd"));

// Footer 生成器：纯数字
FooterGenerator footerGenerator = count -> String.valueOf(count);

// Footer 生成器：R 前缀
FooterGenerator footerGenerator2 = count ->
    String.format("R%05d", count);
```

---

## 6. 性能优化

### 6.1 大文件处理建议

| 文件大小 | Chunk 大小 | 内存建议 | 预期耗时 |
|----------|-----------|----------|----------|
| < 100 MB | 100-500 | 512 MB | < 1分钟 |
| 100 MB - 1 GB | 500-1000 | 1-2 GB | 1-10分钟 |
| > 1 GB | 1000-5000 | 2-4 GB | 10-60分钟 |

### 6.2 JVM 参数建议

```bash
# 大文件处理场景
java -Xms2g -Xmx4g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:+DisableExplicitGC \
     -jar batch-weaver.jar
```

### 6.3 监控指标

| 指标 | 说明 | 预期值 |
|------|------|--------|
| 启动延迟 | open() 耗时 | < 100ms |
| 吞吐量 | 每秒处理行数 | > 10,000 行/秒 |
| 内存占用 | 堆内存增长 | < 200MB (GB 级文件) |

---

## 7. 故障排查

### 7.1 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| Footer 误判 | 数据行与 Footer 格式相同 | 自定义 FooterLineDetector |
| Header 误判 | 数据行被识别为 Header | 调整 HeaderParser 逻辑 |
| 内存溢出 | Chunk 过大 | 减小 chunk-size |
| 无限循环 | handleEndOfFile 未清空 prevLine | 确保设置 `prevLine = null` |

### 7.2 调试日志

```yaml
logging:
  level:
    com.batchweaver.core.fileprocess.reader: DEBUG
```

**日志输出**：

```
DEBUG HeaderFooterAwareReader - State: START, reading first line
DEBUG HeaderFooterAwareReader - First line detected as HEADER: 20260120
DEBUG HeaderFooterAwareReader - Header parsed: 2026-01-20
DEBUG HeaderFooterAwareReader - State: DATA, processing data line
DEBUG HeaderFooterAwareReader - Footer detected: 3
DEBUG HeaderFooterAwareReader - Footer validation passed: expected=3, actual=3
```

---

## 8. 最佳实践

### 8.1 配置建议

| 场景 | HeaderParser | FooterParser | FooterValidator |
|------|--------------|--------------|-----------------|
| 标准格式 | ✅ 配置 | ✅ 配置 | ✅ 配置 |
| 无头尾 | ❌ 不配置 | ❌ 不配置 | ❌ 不配置 |
| 有头无尾 | ✅ 配置 | ❌ 不配置 | ❌ 不配置 |
| 有尾无头 | ❌ 不配置 | ✅ 配置 | ✅ 配置 |

### 8.2 性能建议

1. **大文件处理**：使用 HeaderFooterAwareReader（零启动延迟）
2. **小文件处理**：可使用传统 FlatFileItemReader + linesToSkip
3. **无头尾文件**：直接使用 FlatFileItemReader，无需额外配置

### 8.3 安全建议

1. **路径校验**：使用 `FilePathNormalizer` 防止路径遍历
2. **编码检查**：确保文件编码为 UTF-8
3. **大小限制**：设置文件大小上限，防止恶意超大文件

---

**文档结束**
