# BatchWeaver 测试文档

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档版本** | 1.0.0 |
| **创建日期** | 2026-01-20 |
| **适用框架** | BatchWeaver (基于 Spring Batch 5.x) |
| **测试环境** | Java 21 + Spring Boot 3.5.7 + SQL Server 2022 |

---

## 1. 测试环境配置

### 1.1 环境要求

| 组件 | 版本要求 |
|------|----------|
| JDK | 21+ |
| Maven | 3.8+ |
| SQL Server | 2022 |
| Spring Boot | 3.5.7 |

### 1.2 数据库配置

#### 创建数据库

```sql
CREATE DATABASE BatchWeaverDB;
CREATE DATABASE DB2_Business;
CREATE DATABASE DB3_Business;
CREATE DATABASE DB4_Business;
```

#### 配置文件位置

```
src/main/resources/application.yml
```

#### 关键配置项

```yaml
spring:
  datasource:
    db1:
      jdbc-url: jdbc:sqlserver://localhost:1433;databaseName=BatchWeaverDB;encrypt=true;trustServerCertificate=true
      username: sa
      password: YourPassword123
    db2:
      jdbc-url: jdbc:sqlserver://localhost:1433;databaseName=DB2_Business;encrypt=true;trustServerCertificate=true
      username: sa
      password: YourPassword123
  batch:
    job:
      enabled: false  # 禁止自动启动，通过 JobLauncher 手动触发
```

### 1.3 创建测试表

```sql
-- DB2: 用户表
USE DB2_Business;
CREATE TABLE DEMO_USER (
    id INT PRIMARY KEY,
    name NVARCHAR(100),
    email NVARCHAR(200),
    birth_date DATE
);

-- DB3/DB4: 类似结构
USE DB3_Business;
CREATE TABLE DEMO_USER (
    id INT PRIMARY KEY,
    name NVARCHAR(100),
    email NVARCHAR(200),
    birth_date DATE
);
```

---

## 2. 测试数据准备

### 2.1 测试文件目录结构

```
data/
├── input/
│   ├── demo_users.txt           # 基础测试文件
│   ├── format1_users.txt        # 格式1: yyyyMMdd + 纯数字
│   ├── format2_users.txt        # 格式2:MMddyyyy + R前缀
│   ├── format3_users.txt        # 格式3: 无头尾
│   └── invalid_users.txt        # 异常测试文件
└── output/
    ├── format1_export.txt       # 格式1导出
    ├── format2_export.txt       # 格式2导出
    └── result_export.txt        # 结果导出
```

### 2.2 测试文件内容

#### demo_users.txt (基础文件)

```
H|20260120|USER_IMPORT
1|张三|25|zhangsan@example.com|1990-01-15
2|李四|30|lisi@example.com|1985-06-20
3|王五|28|wangwu@example.com|1987-03-10
T|3
```

#### format1_users.txt (格式1: yyyyMMdd + 纯数字)

```
20260120
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
3
```

#### format2_users.txt (格式2: MMddyyyy + R前缀)

```
01202026
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
R00003
```

#### format3_users.txt (格式3: 无头尾)

```
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
```

#### invalid_users.txt (异常测试)

```
20260119
张三,25,zhangsan@example.com,1990-01-15
李四,INVALID_EMAIL,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
3
```

---

## 3. Job 测试用例

### Job1: 条件流程测试 (Conditional Flow)

#### 测试目的
验证 Spring Batch 的条件分支功能，根据数据处理结果执行不同流程。

#### 配置类
```
com.batchweaver.batch.config.DemoJobConfig
```

#### Job名称
```
demoJob
```

#### 测试场景

| 场景 | 描述 | 预期结果 |
|------|------|----------|
| **正向** | 正常执行导入 | ✅ Step执行完成，状态COMPLETED<br>✅ DB2插入3条记录 |
| **负向** | 数据包含错误行（启用skip） | ✅ 跳过错误行，完成其他记录<br>⚠️ 日志记录skip次数 |

#### 测试步骤

1. **准备阶段**
   ```sql
   -- 清空DB2业务表
   DELETE FROM DB2_Business.dbo.DEMO_USER;
   ```

2. **执行Job**
   ```bash
   # 方法1: 使用 JobLauncher
   mvn spring-boot:run -Dspring-boot.run.arguments="--job.name=demoJob"

   # 方法2: 使用 JUnit 测试
   mvn test -Dtest=JobLauncherTest#testDemoJob
   ```

3. **验证结果**
   ```sql
   -- 验证数据导入
   SELECT COUNT(*) FROM DB2_Business.dbo.DEMO_USER;
   -- 预期结果: 3

   -- 验证元数据
   SELECT JOB_NAME, STATUS, EXIT_CODE
   FROM BatchWeaverDB.dbo.BATCH_JOB_EXECUTION
   WHERE JOB_NAME = 'demoJob';
   -- 预期结果: STATUS=COMPLETED, EXIT_CODE=COMPLETED
   ```

#### 预期输出值

| 指标 | 预期值 |
|------|--------|
| 读取记录数 | 3 |
| 写入记录数 | 3 |
| 跳过记录数 | 0 |
| Job状态 | COMPLETED |
| 执行时间 | < 5秒 |

#### 异常场景测试

| 异常类型 | 触发方式 | 预期行为 |
|----------|----------|----------|
| 文件不存在 | 删除input文件 | 抛出 FileNotFoundException |
| 数据格式错误 | 修改某列格式为非法 | 跳过该行（skipLimit=10） |
| 数据库连接失败 | 停止SQL Server | 抛出 SQLException，Job失败 |

---

### Job2: 批处理模式测试 (Chunk-Oriented Processing)

#### 测试目的
验证基于 Chunk 的批处理模式，测试 commit-interval 和事务边界。

#### 配置类
```
com.batchweaver.batch.config.DemoJobConfig
```

#### Chunk配置
```yaml
batch:
  chunk-size: 100  # 每100条记录提交一次
```

#### 测试场景

| 场景 | 数据量 | Chunk大小 | 预期提交次数 |
|------|--------|-----------|--------------|
| **小批量** | 250条 | 100 | 3次 (100+100+50) |
| **大批量** | 10,000条 | 1000 | 10次 |
| **单条** | 1条 | 100 | 1次 |

#### 测试步骤

1. **准备大批量测试文件**
   ```bash
   # 生成10,000条测试数据
   python scripts/generate_test_data.py --count 10000 --output data/input/large_users.txt
   ```

2. **执行Job并监控**
   ```bash
   mvn test -Dtest=ChunkProcessingTest#testLargeChunkProcessing
   ```

3. **验证事务提交**
   ```sql
   -- 检查中间状态（Job执行期间）
   -- 应该能看到分批提交的数据量增长
   SELECT COUNT(*) FROM DB2_Business.dbo.DEMO_USER;
   ```

#### 预期输出值

| 数据量 | Chunk大小 | 预期耗时 | 内存占用 |
|--------|-----------|----------|----------|
| 1,000 | 100 | < 2秒 | < 50MB |
| 10,000 | 1000 | < 10秒 | < 100MB |
| 100,000 | 10000 | < 60秒 | < 200MB |

---

### Job3: 文件导入测试 (File Import)

#### 测试目的
验证不同格式的文件导入功能，包括 Header/Footer 校验。

#### 配置类
```
com.batchweaver.core.fileprocess.example.ImportJobExamples
```

#### Job列表

| Job名称 | 文件格式 | Header | Footer |
|---------|----------|--------|--------|
| format1ImportJob | yyyyMMdd + 纯数字 | `20260120` | `3` |
| format2ImportJob | MMddyyyy + R前缀 | `01202026` | `R00003` |
| format3ImportJob | 无头尾 | 无 | 无 |

#### 测试场景

##### 场景1: 格式1正常导入

**前置条件**
```
data/input/format1_users.txt 存在且内容正确
```

**测试步骤**
```java
JobExecution execution = jobLauncher.run(
    format1ImportJob,
    new JobParametersBuilder()
        .addLong("timestamp", System.currentTimeMillis())
        .toJobParameters()
);
```

**预期结果**
- ✅ Job状态: COMPLETED
- ✅ 读取记录数: 3
- ✅ Header校验通过
- ✅ Footer校验通过 (count=3)
- ✅ DB2插入3条记录

**预期输出值**
```
Header parsed: 2026-01-20
Footer validation passed: expected=3, actual=3
```

##### 场景2: 格式2正常导入

**前置条件**
```
data/input/format2_users.txt 存在且内容正确
```

**预期结果**
- ✅ Job状态: COMPLETED
- ✅ 读取记录数: 3
- ✅ Header解析: MMddyyyy格式
- ✅ Footer解析: R前缀识别

##### 场景3: 无头尾导入

**前置条件**
```
data/input/format3_users.txt 存在且无头尾
```

**预期结果**
- ✅ Job状态: COMPLETED
- ✅ 读取记录数: 3
- ✅ 无Header/Footer校验

##### 场景4: Header日期不匹配（负向）

**前置条件**
```
data/input/format1_users.txt Header日期为 20260119（非今天）
```

**测试步骤**
```java
// 执行 format1ImportJob
// 触发 HeaderValidator 校验
```

**预期结果**
- ❌ Job状态: FAILED
- ❌ 异常: IllegalStateException("Date mismatch")
- ✅ 元数据表记录FAILED状态

**预期输出值**
```
ERROR HeaderValidator: Date mismatch - expected: 2026-01-20, actual: 2026-01-19
```

##### 场景5: Footer数量不匹配（负向）

**前置条件**
```
data/input/format1_users.txt Footer count=5（实际只有3条数据）
```

**预期结果**
- ❌ Job状态: FAILED
- ❌ 异常: IllegalStateException("Count mismatch")
- ❌ FooterValidator校验失败

**预期输出值**
```
ERROR FooterValidator: Count mismatch - expected: 5, actual: 3
```

---

### Job4: 文件导出测试 (File Export)

#### 测试目的
验证数据从数据库导出到文件的功能，包括 Header/Footer 生成。

#### 配置类
```
com.batchweaver.core.fileprocess.example.ExportJobExamples
```

#### Job列表

| Job名称 | 输出文件 | Header格式 | Footer格式 |
|---------|----------|------------|------------|
| format1ExportJob | format1_export.txt | yyyyMMdd | 纯数字 |
| format2ExportJob | format2_export.txt | MMddyyyy | R前缀 |

#### 测试场景

##### 场景1: 格式1导出

**前置条件**
```sql
-- DB2包含测试数据
INSERT INTO DB2_Business.dbo.DEMO_USER VALUES
(1, N'张三', 'zhangsan@example.com', '1990-01-15'),
(2, N'李四', 'lisi@example.com', '1985-06-20'),
(3, N'王五', 'wangwu@example.com', '1987-03-10');
```

**测试步骤**
```java
JobExecution execution = jobLauncher.run(
    format1ExportJob,
    new JobParametersBuilder()
        .addLong("timestamp", System.currentTimeMillis())
        .toJobParameters()
);
```

**预期结果**
- ✅ Job状态: COMPLETED
- ✅ 生成文件: data/output/format1_export.txt
- ✅ 文件内容格式正确

**预期文件内容**
```
20260120
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
3
```

##### 场景2: 格式2导出

**预期文件内容**
```
01202026
张三,25,zhangsan@example.com,1990-01-15
李四,30,lisi@example.com,1985-06-20
王五,28,wangwu@example.com,1987-03-10
R00003
```

##### 场景3: 空数据导出

**前置条件**
```sql
DELETE FROM DB2_Business.dbo.DEMO_USER;
```

**预期结果**
- ✅ Job状态: COMPLETED
- ✅ 文件只包含 Header + Footer (count=0)

**预期文件内容**
```
20260120
0
```

##### 场景4: 大数据量导出

**前置条件**
```sql
-- 插入100,000条测试数据
```

**预期输出值**
| 数据量 | 预期耗时 | 文件大小 |
|--------|----------|----------|
| 10,000 | < 5秒 | ~2MB |
| 100,000 | < 30秒 | ~20MB |

---

### Job5: 复杂工作流测试 (Complex Workflow)

#### 测试目的
验证多步骤、条件分支、邮件通知的复杂工作流。

#### 工作流步骤

```
┌─────────────────────────────────────────────────────────────┐
│                       Job5: Complex Workflow                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Step1: Import (调用Job3)                                    │
│      ↓                                                       │
│  Step2: Update Data (DB2 → DB3/DB4)                         │
│      ↓                                                       │
│  Step3: Decision Check (检查处理结果)                        │
│      ↓           ↓                                           │
│   [失败]        [成功]                                       │
│      ↓           ↓                                           │
│  Step4:        Step5:                                        │
│  发送失败邮件   发送成功邮件                                  │
│      ↓           ↓                                           │
│  Step6: Export (导出更新后数据)                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 配置类
```
com.batchweaver.batch.config.ComplexWorkflowConfig (需实现)
```

#### 测试场景

##### 场景1: 成功流程 (Step3 → Step5 → Step6)

**前置条件**
```
1. data/input/workflow_users.txt 包含3条有效数据
2. DB2/DB3/DB4 表已清空
3. 邮件服务器已配置（或使用Mock）
```

**测试步骤**

```java
@Test
public void testComplexWorkflow_Success() throws Exception {
    // 1. 执行 Job5
    JobExecution execution = jobLauncher.run(
        complexWorkflowJob,
        new JobParametersBuilder()
            .addLong("timestamp", System.currentTimeMillis())
            .addString("inputFile", "data/input/workflow_users.txt")
            .toJobParameters()
    );

    // 2. 等待完成
    while (execution.isRunning()) {
        Thread.sleep(1000);
    }

    // 3. 验证结果
    assertEquals(BatchStatus.COMPLETED, execution.getStatus());
}
```

**预期结果**

| Step | 状态 | 预期行为 |
|------|------|----------|
| **Step1** | COMPLETED | 从文件导入3条记录到DB2 |
| **Step2** | COMPLETED | 从DB2复制数据到DB3/DB4 |
| **Step3** | COMPLETED | 决策检查通过（数据处理成功） |
| **Step4** | SKIPPED | 不执行（Step3判定成功） |
| **Step5** | COMPLETED | ✅ 发送成功邮件 |
| **Step6** | COMPLETED | ✅ 导出数据到 output/result_export.txt |

**验证SQL**

```sql
-- 验证 DB2 数据
SELECT COUNT(*) FROM DB2_Business.dbo.DEMO_USER;
-- 预期: 3

-- 验证 DB3 数据
SELECT COUNT(*) FROM DB3_Business.dbo.DEMO_USER;
-- 预期: 3

-- 验证 DB4 数据
SELECT COUNT(*) FROM DB4_Business.dbo.DEMO_USER;
-- 预期: 3

-- 验证导出文件
!cat data/output/result_export.txt
-- 预期: 包含3条数据 + Header/Footer
```

**预期输出值**

| 指标 | 预期值 |
|------|--------|
| 总执行时间 | < 30秒 |
| 处理记录数 | 3 |
| 邮件发送 | 成功邮件 x 1 |
| 导出文件大小 | ~500 bytes |

##### 场景2: 失败流程 (Step3 → Step4 → 终止)

**前置条件**
```
1. data/input/workflow_users.txt 包含格式错误数据
2. 或者 Step2 的业务逻辑抛出异常
```

**测试步骤**

```java
@Test
public void testComplexWorkflow_Failure() throws Exception {
    // 1. 准备错误数据
    Files.writeString(
        Path.of("data/input/workflow_users.txt"),
        "20260120\n" +
        "张三,INVALID,zhangsan@example.com,1990-01-15\n" +
        "2\n"
    );

    // 2. 执行 Job5
    JobExecution execution = jobLauncher.run(complexWorkflowJob, ...);

    // 3. 验证失败分支
    assertEquals(BatchStatus.FAILED, execution.getStatus());
}
```

**预期结果**

| Step | 状态 | 预期行为 |
|------|------|----------|
| **Step1** | FAILED | 数据格式错误，导入失败 |
| **Step2** | NOT STARTED | Step1失败，未执行 |
| **Step3** | NOT STARTED | 前置Step失败 |
| **Step4** | EXECUTED | ✅ 发送失败邮件 |
| **Step5** | SKIPPED | 不执行（失败分支） |
| **Step6** | SKIPPED | 不执行（未完成处理） |

**预期输出值**

```
ERROR Step1: Field binding failed for column 'age'
ERROR JobExecution: Job failed with status FAILED
INFO Step4: Sending failure notification email
```

##### 场景3: 部分失败（Skip机制）

**前置条件**
```
1. 数据包含少量错误行（skipLimit=100）
2. 大部分数据有效
```

**预期结果**

| Step | 状态 | 预期行为 |
|------|------|----------|
| **Step1** | COMPLETED with skips | 跳过错误行，完成其他 |
| **Step2** | COMPLETED | 处理剩余数据 |
| **Step3** | COMPLETED | 检查跳过日志 |
| **Step5** | COMPLETED | ✅ 发送警告邮件（部分成功） |
| **Step6** | COMPLETED | 导出有效数据 |

**预期输出值**

```
WARNING Step1: Skipped 2 records due to format errors
INFO Step3: Processed 98 records, skipped 2 records
INFO Step5: Sending partial success email
```

---

## 4. 事务隔离测试

### 测试目的
验证元数据事务（tm1）与业务事务（tm2/tm3/tm4）的隔离性。

### 测试场景

| 场景 | 描述 | 验证点 |
|------|------|--------|
| **业务事务回滚** | Step执行失败，业务数据回滚 | ✅ 元数据表有FAILED记录<br>✅ 业务表为空（回滚） |
| **元数据事务提交** | Step失败，元数据正常提交 | ✅ BATCH_JOB_EXECUTION有记录 |

### 测试步骤

```java
@Test
public void testTransactionIsolation() throws Exception {
    // 1. 准备会触发异常的数据
    String invalidData = "20260120\n" +
                         "张三,INVALID,email@example.com,1990-01-15\n" +
                         "1\n";

    // 2. 执行Job
    JobExecution execution = jobLauncher.run(demoJob, ...);

    // 3. 验证业务数据回滚
    long businessCount = jdbcTemplate.queryForLong(
        "SELECT COUNT(*) FROM DB2_Business.dbo.DEMO_USER"
    );
    assertEquals(0, businessCount); // 业务表为空

    // 4. 验证元数据提交
    String jobStatus = jdbcTemplate.queryForObject(
        "SELECT STATUS FROM BatchWeaverDB.dbo.BATCH_JOB_EXECUTION " +
        "WHERE JOB_NAME = 'demoJob'",
        String.class
    );
    assertEquals("FAILED", jobStatus); // 元数据记录失败状态
}
```

### 预期结果

| 验证项 | 预期值 |
|--------|--------|
| 业务表记录数 | 0 |
| 元数据状态 | FAILED |
| EXIT_CODE | FAILED |
| EXIT_MESSAGE | 包含异常堆栈 |

---

## 5. 性能基准测试

### 测试场景

| 数据量 | 文件大小 | 预期吞吐量 | 预期耗时 |
|--------|----------|------------|----------|
| 1,000条 | ~100KB | > 5,000条/秒 | < 1秒 |
| 10,000条 | ~1MB | > 10,000条/秒 | < 5秒 |
| 100,000条 | ~10MB | > 10,000条/秒 | < 30秒 |
| 1,000,000条 | ~100MB | > 8,000条/秒 | < 5分钟 |

### 内存占用基准

| 数据量 | 预期内存占用 | 说明 |
|--------|--------------|------|
| 1,000条 | < 50MB | O(1) 缓存 |
| 100,000条 | < 100MB | 单次扫描 |
| 1,000,000条 | < 200MB | 流式处理 |

### 测试命令

```bash
# 生成测试数据
python scripts/generate_test_data.py --count 1000000 --output data/input/perf_test.txt

# 执行性能测试
mvn test -Dtest=PerformanceTest

# 查看内存监控
jconsole -localhost <pid>
```

---

## 6. 异常场景测试

### 6.1 文件级异常

| 异常类型 | 触发方式 | 预期行为 |
|----------|----------|----------|
| 文件不存在 | 删除input文件 | ❌ FileNotFoundException |
| 文件无读取权限 | chmod 000 file | ❌ SecurityException |
| 文件编码错误 | 使用非UTF-8编码 | ❌ CharacterCodingException |
| 文件被占用 | 文件被其他进程锁定 | ❌ IOException |

### 6.2 数据级异常

| 异常类型 | 示例数据 | 预期行为 |
|----------|----------|----------|
| 列数不足 | `张三,25,email` | ⚠️ 跳过或填充null |
| 列数过多 | `张三,25,email@example.com,1990-01-15,extra` | ⚠️ 忽略多余列 |
| 日期格式错误 | `张三,25,email@example.com,invalid-date` | ⚠️ 跳过该行 |
| 数字格式错误 | `张三,INVALID,email@example.com,1990-01-15` | ⚠️ 跳过该行 |
| CSV注入 | `张三,25,=1+1,1990-01-15` | ✅ 自动转义 |

### 6.3 数据库级异常

| 异常类型 | 触发方式 | 预期行为 |
|----------|----------|----------|
| 连接池耗尽 | 并发执行过多Job | ❌ SQLException: Timeout |
| 主键冲突 | 插入重复ID | ❌ DataIntegrityViolationException |
| 表不存在 | 删除业务表 | ❌ BadSqlGrammarException |
| 事务超时 | 单个Step执行过久 | ❌ TransactionException |

---

## 7. 测试执行命令

### 7.1 运行所有测试

```bash
mvn clean test
```

### 7.2 运行特定Job测试

```bash
# Job1: 条件流程测试
mvn test -Dtest=Job1ConditionalFlowTest

# Job2: 批处理模式测试
mvn test -Dtest=Job2ChunkProcessingTest

# Job3: 文件导入测试
mvn test -Dtest=Job3ImportTest

# Job4: 文件导出测试
mvn test -Dtest=Job4ExportTest

# Job5: 复杂工作流测试
mvn test -Dtest=Job5ComplexWorkflowTest
```

### 7.3 运行集成测试

```bash
# 事务隔离测试
mvn test -Dtest=TransactionIsolationTest

# 性能测试
mvn test -Dtest=PerformanceTest
```

### 7.4 生成测试覆盖率报告

```bash
mvn clean test jacoco:report

# 查看报告
open target/site/jacoco/index.html
```

---

## 8. 故障排查指南

### 8.1 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| Job未启动 | `spring.batch.job.enabled=false` | 使用 JobLauncher 手动触发 |
| 找不到文件 | 路径错误或文件不存在 | 检查 `data/input/` 目录 |
| Header校验失败 | 日期格式不匹配 | 调整 HeaderValidator 逻辑 |
| Footer校验失败 | 数量不匹配 | 检查数据完整性 |
| 事务回滚 | 数据库连接问题 | 检查 `application.yml` 配置 |

### 8.2 日志分析

**启用DEBUG日志**

```yaml
logging:
  level:
    org.springframework.batch: DEBUG
    com.batchweaver: DEBUG
    org.springframework.jdbc.core: DEBUG
```

**关键日志关键词**

- `JobExecution` - Job执行状态
- `StepExecution` - Step执行状态
- `Header parsed` - Header解析成功
- `Footer validation` - Footer校验结果
- `Skipped` - 跳过记录数
- `Rollback` - 事务回滚

---

## 9. 测试清单

### Job1: 条件流程测试

- [ ] 正常执行成功
- [ ] 文件不存在处理
- [ ] 数据格式错误skip
- [ ] 数据库连接失败处理
- [ ] 元数据正确记录

### Job2: 批处理模式测试

- [ ] 小批量测试（< 1000条）
- [ ] 中批量测试（1000-10000条）
- [ ] 大批量测试（> 10000条）
- [ ] Chunk提交次数验证
- [ ] 事务边界验证

### Job3: 文件导入测试

- [ ] 格式1导入成功
- [ ] 格式2导入成功
- [ ] 格式3导入成功
- [ ] Header日期不匹配失败
- [ ] Footer数量不匹配失败
- [ ] 空文件处理
- [ ] 单行文件处理

### Job4: 文件导出测试

- [ ] 格式1导出成功
- [ ] 格式2导出成功
- [ ] 空数据导出
- [ ] 大数据量导出
- [ ] 文件格式验证

### Job5: 复杂工作流测试

- [ ] 成功流程（Step1→2→3→5→6）
- [ ] 失败流程（Step1→3→4）
- [ ] 部分成功流程（Skip机制）
- [ ] 邮件通知验证
- [ ] Step跳过逻辑验证

### 事务隔离测试

- [ ] 业务事务回滚验证
- [ ] 元数据事务提交验证
- [ ] 多数据源隔离验证

### 性能测试

- [ ] 1,000条 < 1秒
- [ ] 10,000条 < 5秒
- [ ] 100,000条 < 30秒
- [ ] 内存占用验证

---

## 10. 附录

### 10.1 测试数据生成脚本

```python
# scripts/generate_test_data.py
import argparse

def generate_test_data(count, output_file):
    with open(output_file, 'w', encoding='utf-8') as f:
        # Header
        f.write("20260120\n")
        # Data
        for i in range(count):
            f.write(f"User{i},25,user{i}@example.com,1990-01-15\n")
        # Footer
        f.write(f"{count}\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--count", type=int, required=True)
    parser.add_argument("--output", type=str, required=True)
    args = parser.parse_args()
    generate_test_data(args.count, args.output)
```

### 10.2 Mock邮件配置

```yaml
# application-test.yml
spring:
  mail:
    host: localhost
    port: 2525  # 使用 Mock Mail Server
    test-connection: false
```

### 10.3 测试结果模板

```
测试日期: _____________
测试人员: _____________
测试环境: _____________

Job1: 条件流程测试     [ ] 通过  [ ] 失败  备注: _______
Job2: 批处理模式测试   [ ] 通过  [ ] 失败  备注: _______
Job3: 文件导入测试     [ ] 通过  [ ] 失败  备注: _______
Job4: 文件导出测试     [ ] 通过  [ ] 失败  备注: _______
Job5: 复杂工作流测试   [ ] 通过  [ ] 失败  备注: _______
事务隔离测试           [ ] 通过  [ ] 失败  备注: _______
性能测试               [ ] 通过  [ ] 失败  备注: _______

总体评价: _____________
签字: _____________
```

---

**文档结束**
