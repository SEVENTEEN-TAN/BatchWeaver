spring.application.name=batch-scheduler

# DataSource Configuration (H2 File-based)
spring.datasource.url=jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MODE=MySQL
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# Druid Configuration
spring.datasource.druid.url=jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;MODE=MySQL
spring.datasource.druid.driver-class-name=org.h2.Driver
spring.datasource.druid.username=sa
spring.datasource.druid.password=
spring.datasource.druid.initial-size=5
spring.datasource.druid.min-idle=5
spring.datasource.druid.max-active=20
spring.datasource.druid.max-wait=60000
spring.datasource.druid.time-between-eviction-runs-millis=60000
spring.datasource.druid.min-evictable-idle-time-millis=300000
spring.datasource.druid.validation-query=SELECT 1
spring.datasource.druid.test-while-idle=true
spring.datasource.druid.test-on-borrow=false
spring.datasource.druid.test-on-return=false
spring.datasource.druid.pool-prepared-statements=true
spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20

# Spring Batch Configuration
# ALWAYS initialize the schema on startup (creates tables if missing)
spring.batch.jdbc.initialize-schema=always
spring.batch.job.enabled=false 
# We disable auto-run on startup because we want to control it via CLI args or Scheduler

# Logging
logging.level.root=INFO
logging.level.com.example.batch=DEBUG
logging.level.org.springframework.batch=INFO
